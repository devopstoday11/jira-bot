#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2015 Alex Turbov <i.zaufi@gmail.com>
#
# JIRA Bot is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# JIRA Bot is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import configparser
import jira
import os
import sys


class Application(object):
    def __init__(self):
        # Try to parse config file option first
        config_parser = argparse.ArgumentParser(
            description='JIRA Issue Creation Bot'
          , add_help=False
          )
        config_parser.add_argument(
            "-c"
          , "--config-file"
          , help="specify config file to use"
          , metavar="FILE"
          )
        args, remaining_argv = config_parser.parse_known_args()

        defaults = {
            "server" : None
          , "verbose" : False
          }

        # Collect configuration data from various places:
        configs = list()
        #  - is there any config file provided via CLI?
        if args.config_file:
            # Ok, lets use it
            configs.append(self._parse_config_file(args.config_file))
        else:
            # Heh, then try to get config data from system-wide and per user config files
            for config_file in ['/etc/jira-bot/jira-bot.conf', os.path.join(os.environ['HOME'], '.jira-botrc')]:
                # TODO Make sure that config file can't be read only by owner!
                if os.path.isfile(config_file):
                    configs.append(self._parse_config_file(config_file))

        # Merge configuration data
        self.config = dict()
        for cfg in configs:
            for section in cfg.sections():
                self.config[section] = dict(cfg[section].items())

        # Ok, now try to parse rest CLI options
        parser = argparse.ArgumentParser(
            # Inherit options from config_parser
            parents=[config_parser]
            # print script description with -h/--help
          , description=__doc__
            # Don't mess with format of description
          , formatter_class=argparse.RawDescriptionHelpFormatter
          )
        parser.add_argument(
            '-v'
          , '--verbose'
          , action='store_true'
          , help='verbose output'
          )
        parser.add_argument(
            '-w'
          , '--show-issue-uri'
          , action='store_true'
          , help='on exit print URI of the issue created'
          )
        parser.add_argument(
            '-s'
          , '--server'
          , help='JIRA server URI'
          )
        parser.add_argument(
            '-u'
          , '--username'
          , help='JIRA account name'
          )
        parser.add_argument(
            '-p'
          , '--password'
          , help='JIRA account password'
          )
        parser.add_argument(
            '-j'
          , '--project'
          , help='JIRA project to use'
          )
        parser.add_argument(
            '-m'
          , '--summary'
          , required=True
          , help='summary text for the issue'
          )
        parser.add_argument(
            '-f'
          , '--attachment'
          , nargs='+'
          , type=argparse.FileType('rb')
          , help='attach a given file to a new issue'
          )
        parser.add_argument(
            'input'
          , nargs='?'
          , type=argparse.FileType('r')
          , default=sys.stdin
          , help='input file with issue description (STDIN if omitted)'
          )

        args = parser.parse_args()

        # Merge CLI options w/ parsed configuration
        target_section = 'default'

        # Check if `--server` is provided
        if args.server is not None:
            # Override used server section
            target_section = args.server
            self.config['default']['server'] = args.server
        elif 'server'  in self.config['default']:
            target_section = self.config['default']['server']
        else:
            raise RuntimeError('JIRA server URI is not provided')

        if target_section not in self.config:
            self.config[target_section] = dict()

        # Check if `--username` is provided
        if args.username is not None:
            self.config[target_section]['username'] = args.username
            # ATTENTION Reset password
            self.config[target_section]['password'] = None

        # Check if `--password` is provided
        if args.password is not None:
            self.config[target_section]['password'] = args.password

        # Check if `--project` is provided
        if args.project is not None:
            self.config[target_section]['project'] = args.project

        # Check if `--summary` is provided
        if args.summary is not None:
            self.config[target_section]['summary'] = args.summary
        else:
            raise RuntimeError('Issue summary is not provided')

        # Check if `--attachment` is provided
        self.config[target_section]['attachments'] = args.attachment if args.attachment is not None else None

        # Check if `--show-issue-url` is provided
        if args.show_issue_uri is not None:
            self.config['default']['show-issue-uri'] = True
        else:
            self.config['default']['show-issue-uri'] = False

        # Check if `--verbose` is provided
        if args.verbose is not None:
            self.config['default']['verbose'] = 'true'

        # Read description data
        self.config[target_section]['description'] = args.input.read().strip()

        # Setting self.verbose to be a 'shortcut' for corresponding configuration option
        self.verbose = 'verbose' in self.config['default'] and self._try_get_bool(self.config['default']['verbose'])
        # TODO Validate options

        # Args seem Ok, ready to run
        #print(repr(self.config))
        #sys.exit(1)


    def _parse_config_file(self, config_file):
        config = configparser.ConfigParser(allow_no_value=True)
        config.read([config_file])
        return config


    def _try_get_bool(self, text):
        text = text.strip()
        if text == 'yes' or text == 'true' or text == '1':
            return True
        if text == 'no' or text == 'false' or text == '0':
            return False

        raise RuntimeError('Invalid boolean value: "{}"'.format(text))


    def run(self):
        server = self.config['default']['server']
        # Make some SPAM
        if self.verbose:
            print(
                '[DEBUG] Connecting to {} using {} {}'.format(
                    server
                  , 'login "{}"'.format(self.config[server]['username']) if 'username' in self.config[server] else 'anonymous login'
                  , 'and password provided' if self.config[server]['password'] is not None else 'w/o password'
                  )
                , file=sys.stderr
              )
        if 'username' in self.config[server]:
            auth=(self.config[server]['username'], self.config[server]['password'])

        # Connecting...
        conn = jira.JIRA(options={'server': server}, basic_auth=auth)
        # Make sure the project specified is really exists
        prj = conn.project(self.config[server]['project'])
        if prj is None:
            raise RuntimeError('Specified project "" not found'.format(self.config[server]['project']))

        if self.verbose:
            print('[DEBUG] Got project id for {}: {}'.format(self.config[server]['project'], prj.id), file=sys.stderr)

        # Prepare data for a new issue
        issue_dict = {
            'project': {'id': prj.id}
          , 'summary': self.config[server]['summary']
          , 'description': self.config[server]['description']
          , 'issuetype': {'name': 'Bug'}
          }
        if self.verbose:
            print('[DEBUG] Going to create an issue w/ data: {}'.format(repr(issue_dict)), file=sys.stderr)

        # Create it!
        issue = conn.create_issue(fields=issue_dict)
        if issue is None:
            # TODO More diagnostic!
            raise RuntimeError('Fail to add an issue')

        if self.verbose:
            print('[DEBUG] Issue {} created'.format(issue.key), file=sys.stderr)

        # Attach files if any
        if self.config[server]['attachments'] is not None:
            for a in self.config[server]['attachments']:
                if self.verbose:
                    print('[DEBUG] Going to attach file "{}" to issue {}'.format(a.name, issue.key), file=sys.stderr)
                conn.add_attachment(issue, attachment=a)

        # Print URL to browse created task if needed
        if self.config['default']['show-issue-uri']:
            print('{}/browse/{}'.format(server, issue.key))

        # Set exit code to SUCCESS
        return os.EX_OK


#
# Main entry point
#
if __name__ == "__main__":
    try:
        a = Application()
        sys.exit(a.run())
    except KeyboardInterrupt:
        sys.exit(1)
    except RuntimeError as ex:
        print('Error: {}'.format(ex), file=sys.stderr)
        sys.exit(1)
